# Modern C++ 类模板

 > 类模板定义了一个类，其中，将一些变量的类型、方法和参数类型和方法的参数类型指定为参数。本节使用了一个Grid容器作为示例。不同小节会向Grid容器添加一些特性。源码见code/grid

- [Modern C++ 类模板](#modern-c-类模板)
  - [编译器处理模板的原理](#编译器处理模板的原理)
    - [1. 选择性实例化](#1-选择性实例化)
    - [2. 模板对类型的要求](#2-模板对类型的要求)
  - [将模板代码分布到多个文件中](#将模板代码分布到多个文件中)

## 编译器处理模板的原理

编译器遇到模板方法时，会进行语法检查，但是并不编译模板。编译器无法编译模板定义，因为不知道它要使用什么类型。如果不知道x和y的类型，那么编译器就无法为x=y这样的语句生成代码。

编译器遇到一个实例化的模板时，例如 `Grid<int>`，就会将模板类定义的每一个T替换为int，从而生成Grid模板的int版本代码。当编译器遇到这个模板的另一个示例时，就会生成另一个版本的Grid类。

### 1. 选择性实例化

类模板的隐式实例化如下所示：

```cpp
Grid<int> myIntGrid;
```

编译器总是为类模板的所有虚方法生成代码。但是对于非虚方法，编译器只会为那些实际为某种类型调用的非虚方法生成代码。例如，给定前面定义的Grid模板，假设在 `main()` 函数中编写这段代码：

```cpp
Grid<int> myIntGrid;
myIntGrid.at(0, 0) = 10;
```

编译器只会为int版本的Grid类生成无参构造函数、析构函数和非常量 `at()` 方法的代码。它不会为其他方法生成代码。编译器的以上行为称为 **选择性实例化(selective instantiation)**。

存在这样的危险：在类模板方法中存在编译错误，而这些错误会被忽略。类模板中未使用的方法可能包含语法错误，而这些错误不会被编译。通过显式的模板实例化，可以强制编译器为所有方法生成代码，包括虚方法和非虚方法。示例如下：

```cpp
template class Grid<int>;
```

当使用显式模板实例化时，不要只尝试使用基本数据类型来实例化类模板，而应该尝试使用更复杂的类型来实例化模板。

### 2. 模板对类型的要求

在编写与类型无关的代码时，必须对这些类型有一些假设。例如，在Grid类模板中，假设元素类型T时可以被析构的、可复制/移动的。

如果试图用一种不支持模板使用的所有操作的类型对模板进行实例化，那么这段代码无法编译。C++20引入 **概念(concepts)** ，允许编写编译器可以解释和验证的模板参数要求。如果传递给实例化模板的模板参数不满足这些要求，编译器会生成更多可读的错误。该部分内容会在之后讨论。

## 将模板代码分布到多个文件中

对于类模板，编译器必须可以从使用它们的任何源文件中获取类模板定义和方法定义。有几种机制可以实现这一点。